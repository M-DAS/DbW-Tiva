#define PART_TM4C123GH6PM 1;

#include <stdint.h>
#include <stdbool.h>
#include "inc/tm4c123gh6pm.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "driverlib/sysctl.h"
#include "driverlib/interrupt.h"
#include "driverlib/gpio.h"
#include "driverlib/timer.h"
#include "driverlib/pin_map.h"
#include "driverlib/can.h"

#include "Globals_and_Defines.h"
#include "PID_Cntrl.h"
#include "Pressure_ADC.h"

void CAN_Setup(void)
{
	tCANMsgObject sMsgObjectRx;

	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
	while(!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOE))
	{}

	GPIOPinConfigure(GPIO_PE4_CAN0RX);
	GPIOPinConfigure(GPIO_PE5_CAN0TX);

	GPIOPinTypeCAN(GPIO_PORTE_BASE, GPIO_PIN_4 | GPIO_PIN_5);
	SysCtlPeripheralEnable(SYSCTL_PERIPH_CAN0);
	while(!SysCtlPeripheralReady(SYSCTL_PERIPH_CAN0))
	{}

	CANInit(CAN0_BASE);
	CANBitRateSet(CAN0_BASE, SysCtlClockGet(), 250000);	
	CANIntEnable(CAN0_BASE, CAN_INT_MASTER);
	IntEnable(INT_CAN0);
	CANEnable(CAN0_BASE);
		
	sMsgObjectRx.ui32MsgID = 0;
	sMsgObjectRx.ui32MsgIDMask = 0;
	sMsgObjectRx.ui32Flags = MSG_OBJ_RX_INT_ENABLE | MSG_OBJ_USE_ID_FILTER;
	sMsgObjectRx.ui32MsgLen = 8;
	CANMessageSet(CAN0_BASE, 2, &sMsgObjectRx, MSG_OBJ_TYPE_RX);
}

void CAN0_Handler(void)
{
	uint32_t int_status;
	uint8_t data_array[8];
	uint16_t eventType;
	uint16_t srcId;
	tCANMsgObject sMsgObjectRx;
	sMsgObjectRx.pui8MsgData = data_array;

	int_status = CANIntStatus(CAN0_BASE, CAN_INT_STS_CAUSE);  
	CANStatusGet(CAN0_BASE, CAN_STS_CONTROL);

	
	if (int_status == 0x2)   //interrupt was generated by receive object
	{
		CANMessageGet(CAN0_BASE, 2, &sMsgObjectRx, true);   //get received data
		g_new_CAN_data = true;
			
		switch(sMsgObjectRx.ui32MsgID)
		{
			case estop_address:
				if(data_array[0] == 66)
				{
					enableDbW = false;
					PF2 = 0x00;
					PF1 = 0x02;
				}
			break;
			case dsrc_address:
				dsrc = !dsrc;
			break;
			case brake_board_address:
			isServiced = false;
			srcId = data_array[0];
			eventType = data_array[1];
			if(srcId == 0x01 ||srcId == 0x02)
			{
				if(eventType == 0x00)
				{
					if(enableDbW == true)
					{
						updateSetPoint2(data_array[2], data_array[3]);//msb,lsb
					}
				}
				else if(eventType == 0x01)
				{
					  enableDbW = !enableDbW;
				}	
			}
			break;	
		}
	}
}

void send_brake_pressure_percentage()
{		
	  tCANMsgObject sMsgObjectTx;
	  uint8_t pui8BufferOut[3] = {0x00, 0x00, 0x00};
		uint32_t pressure = brakePressure;
		
		int32_t v_out; 
	
		if(pressure > 920)
			pressure = 920;
		if(pressure < 620)
			pressure = 620;
																						 //920 = 100%, 620 = 0%  ... M = 1/3 .... B = -206.6 ... 2^16 scaling
		v_out = (21845*pressure - 13544106)>>16; //Voltage values ||| .511V = 620 |||| .750 = 920
		
		if(v_out < 0)
			v_out = 0;
		if(v_out > 100)
			v_out = 0;
		
		pui8BufferOut[0] = 0x00; //SRC ID
		pui8BufferOut[1] = ((v_out&0xFF00)>>8);//MSB
		pui8BufferOut[2] = (v_out&0x00FF);//LSB
			
		//Configure transmit of message object.
		sMsgObjectTx.ui32MsgID = feedback_address;
		sMsgObjectTx.ui32Flags = 0;
		sMsgObjectTx.ui32MsgLen = 3;
		sMsgObjectTx.pui8MsgData = pui8BufferOut;
		
		//Send out data on CAN
		CANMessageSet(CAN0_BASE, 9, &sMsgObjectTx, MSG_OBJ_TYPE_TX);
}

void send_Estop()
{		
	  tCANMsgObject sMsgObjectTx;
	  uint8_t pui8BufferOut[1] = {0x66};

		//Configure transmit of message object.
		sMsgObjectTx.ui32MsgID = estop_address;
		sMsgObjectTx.ui32Flags = 0;
		sMsgObjectTx.ui32MsgLen = 1;
		sMsgObjectTx.pui8MsgData = pui8BufferOut;
		
		//Send out data on CAN
		CANMessageSet(CAN0_BASE, 8, &sMsgObjectTx, MSG_OBJ_TYPE_TX);
}
