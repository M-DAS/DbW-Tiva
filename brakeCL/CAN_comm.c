#define PART_TM4C123GH6PM 1;

#include <stdint.h>
#include <stdbool.h>
#include "inc/tm4c123gh6pm.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "driverlib/sysctl.h"
#include "driverlib/interrupt.h"
#include "driverlib/gpio.h"
#include "driverlib/timer.h"
#include "driverlib/pin_map.h"
#include "driverlib/can.h"

#include "Globals_and_Defines.h"
#include "PID_Cntrl.h"
#include "Pedal_ADC.h"



void CAN_Setup(void)
{
	tCANMsgObject sMsgObjectRx;
	//Enable PORTE
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
	while(!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOE))
	{}

	// Configure the GPIO pin muxing to select CAN0 functions for these pins.
	// This step selects which alternate function is available for these pins.
	GPIOPinConfigure(GPIO_PE4_CAN0RX);
	GPIOPinConfigure(GPIO_PE5_CAN0TX);

	//Configure the pins for CAN
	GPIOPinTypeCAN(GPIO_PORTE_BASE, GPIO_PIN_4 | GPIO_PIN_5);

	
	// Enable the CAN0 module.
	SysCtlPeripheralEnable(SYSCTL_PERIPH_CAN0);
	while(!SysCtlPeripheralReady(SYSCTL_PERIPH_CAN0))
	{}

	// Reset the state of all the message objects and the state of the CAN
	// module to a known state.
	CANInit(CAN0_BASE);

	// Configure the controller for 250 Kbit operation.
	CANBitRateSet(CAN0_BASE, SysCtlClockGet(), 250000);
		
	CANIntEnable(CAN0_BASE, CAN_INT_MASTER);
	IntEnable(INT_CAN0);
		
	//Set CAN0 to looback test mode
	//CAN0_CTL_R |= CAN_CTL_TEST;
	//CAN0_TST_R |= CAN_TST_LBACK;
	
	//Start CAN0 peripheral
	CANEnable(CAN0_BASE);
		
	sMsgObjectRx.ui32MsgID = 0;
	sMsgObjectRx.ui32MsgIDMask = 0;
	sMsgObjectRx.ui32Flags = MSG_OBJ_RX_INT_ENABLE | MSG_OBJ_USE_ID_FILTER;
	sMsgObjectRx.ui32MsgLen = 8;
	CANMessageSet(CAN0_BASE, 2, &sMsgObjectRx, MSG_OBJ_TYPE_RX);
}

void CAN0_Handler(void)
{
	uint32_t int_status, CAN_status;
	uint8_t data_array[8];
	tCANMsgObject sMsgObjectRx;
	sMsgObjectRx.pui8MsgData = data_array;
	//get interrupt status
	int_status = CANIntStatus(CAN0_BASE, CAN_INT_STS_CAUSE);  
	//get CAN status
	CAN_status = CANStatusGet(CAN0_BASE, CAN_STS_CONTROL);
	if (int_status == 0x2)   //interrupt was generated by receive object
	{
		CANMessageGet(CAN0_BASE, 2, &sMsgObjectRx, true);   //get received data
		g_new_CAN_data = true;
			
		switch(sMsgObjectRx.ui32MsgID)
		{
			case brake_board_address:
			isServiced = false;
			updateSetPoint2(data_array[1], data_array[2]);
			break;
		
		}
	}
}


void send_brake_pressure_percentage()
{		
	  tCANMsgObject sMsgObjectTx;
	  uint8_t pui8BufferOut[8] = {0x01, 0x0a, 0x0f, 0x02, 0x0d,0x04, 0x00, 0x00};
		uint16_t pressure = get_brake_pressure();
		
		//uint16_t v_out = (100000 * pressure);
		
		uint16_t v_out = (19854 * pressure)>>4;
		//uint16_t v_out = (5* pressure)>>4;

//		uint16_t v_out = 943;
//		
//		if(pressure > 943)
//			v_out = 100;
//		else if(pressure < 632)
//			v_out = 0;
//		else
//			v_out = 69;
		
		pui8BufferOut[2] = v_out & 0xFF;
		pui8BufferOut[1] = (v_out &0xFF00)>>8;
			
		
		//Configure transmit of message object.
		sMsgObjectTx.ui32MsgID = 0x1CDBFFFF;
		sMsgObjectTx.ui32Flags = 0;
		sMsgObjectTx.ui32MsgLen = 8;
		sMsgObjectTx.pui8MsgData = pui8BufferOut;
		
		//Send out data on CAN
		CANMessageSet(CAN0_BASE, 9, &sMsgObjectTx, MSG_OBJ_TYPE_TX);
}







